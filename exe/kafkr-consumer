#!/usr/bin/env ruby

require "kafkr"
require 'find'

PORT = ENV["KAFKR_PORT"] || 4000
$current_consumer = nil

# Signal handler for restarting the consumer
Signal.trap("USR1") do
  puts "Received signal to restart consumer."
  stop_consumer
  start_consumer
end

def stop_consumer
  if $current_consumer
    puts "Stopping current consumer..."
    # Add logic to gracefully stop the consumer, e.g., closing connections
    $current_consumer = nil
  end
end

def list_registered_handlers
  Kafkr::Consumer.handlers.each do |handler|
    handler_name = handler.class.name.split('::').last
    handler_name.gsub!(/Handler$/, '') # Remove 'Handler' from the name
    puts "#{handler_name} loaded - ok!"
  end
end

# Method to start the consumer
def start_consumer
  puts "Starting consumer on port #{PORT}!"
  Kafkr::Consumer.configure do |config|
    config.port = PORT
  end

  Kafkr::Consumer.load_handlers
  list_registered_handlers

  $current_consumer = Kafkr::Consumer.new
  $current_consumer.listen do |message|
    # Processing of the message
  end
end

def monitor_handlers
  puts "monitoring!"
  last_checked = Time.now

  loop do
    changed = false
    puts "checking #{Kafkr::Consumer::HANDLERS_DIRECTORY} for changes!"
    Find.find(Kafkr::Consumer::HANDLERS_DIRECTORY) do |path|
      puts "checking #{path} for changes!"
      if File.file?(path) && File.mtime(path) > last_checked
        load path
        changed = true
      end
    end

    if changed
      puts "changed!"
      Kafkr::Consumer.load_handlers
      Process.kill("USR1", Process.pid)  # Sending signal to self to restart consumer
    end

    sleep 5
    last_checked = Time.now
  end
end

begin
  require "kafkr"
rescue LoadError => e
  puts "Failed to load Kafkr: #{e.message}"
  exit(1)
end


# Main execution block
begin
  monitoring_thread = Thread.new { monitor_handlers }
  start_consumer
rescue => e
  puts "An error occurred: #{e.message}"
  exit(1)
rescue Interrupt
  puts "\nConsumer shutting down gracefully..."
  stop_consumer
  exit(0)
ensure
  monitoring_thread.kill if monitoring_thread
end


